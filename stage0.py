from __future__ import annotations

"""Stage 0: –ø–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç dev-–≤–µ—Ç–∫–∏ –≤ –ø–∞–∫–µ—Ç–∞—Ö –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º —Ä–µ–ª–∏–∑–Ω–æ–≥–æ —Ü–∏–∫–ª–∞.

–ó–∞–ø—É—Å–∫:
    uv run release-tool-stage0 [--branch dev_branch] [--base-branch main] [--push] [--dry-run]

–î–µ–π—Å—Ç–≤–∏—è –ø–æ –∫–∞–∂–¥–æ–º—É –ø–∞–∫–µ—Ç—É (–ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –∫–∞—Ç–∞–ª–æ–≥–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π):
1. `git fetch <remote>` (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é origin).
2. `git checkout -B <branch> <remote>/<base_branch>` ‚Äî —Å–æ–∑–¥–∞—ë–º/–æ–±–Ω–æ–≤–ª—è–µ–º dev-–≤–µ—Ç–∫—É
   –æ—Ç –∞–∫—Ç—É–∞–ª—å–Ω–æ–π <base_branch>.
3. (–æ–ø—Ü.) `git push --set-upstream <remote> <branch>` ‚Äî –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω --push.

–≠—Ç–æ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä—É–µ—Ç —à–∞–≥, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–Ω—å—à–µ –≤—ã–ø–æ–ª–Ω—è–ª—Å—è –≤—Ä—É—á–Ω—É—é –ø–µ—Ä–µ–¥ Stage 2/3/4.
"""

import argparse
import pathlib
import sys
from dataclasses import dataclass

from .config import load_config
from .git_utils import _push_repo, _run_git, has_commits_to_push, GitError
from .git_helpers import (
    remote_branch_exists,
    local_branch_exists,
    fast_forward,
    checkout_branch,
    ensure_tracking,
    calc_ahead_behind,
    temporary_stash,
)


@dataclass
class PackageResult:
    name: str
    push_done: bool
    stash_kept: bool
    ahead: int
    behind: int
    uncommitted: bool


def _process_package(
    pkg: pathlib.Path,
    branch: str,
    base: str,
    remote: str,
    push: bool,
    dry_run: bool,
    no_stash: bool,
    stash_name: str,
    keep_stash: bool,
    fallback_head: bool,
    fallback_local: bool,
) -> tuple[bool, bool, int, int]:
    """–ì–æ—Ç–æ–≤–∏—Ç dev-–≤–µ—Ç–∫—É *branch* –≤ –ø–∞–∫–µ—Ç–µ *pkg*.

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        push_done, stash_kept, ahead, behind
    """

    # --- dry-run ---------------------------------------------------------
    if dry_run:
        print(f"[stage0]   [dry-run] git -C {pkg} fetch {remote}")
        print(f"[stage0]   [dry-run] git -C {pkg} checkout -B {branch} {remote}/{base}")
        if push:
            print(f"[stage0]   [dry-run] git -C {pkg} push --set-upstream {remote} {branch}")
        return False, False, 0, 0

    # --------------------------------------------------------------------
    _run_git(pkg, ["fetch", remote], capture=False)

    remote_dev_exists = remote_branch_exists(pkg, remote, branch)
    local_dev_exists = local_branch_exists(pkg, branch)

    stash_kept = False

    if remote_dev_exists:
        # --- —Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è –≤–µ—Ç–∫–∞ –Ω–∞ remote --------------------------------
        start_point = None if local_dev_exists else f"{remote}/{branch}"
        checkout_branch(pkg, branch, start_point)

        try:
            fast_forward(pkg, f"{remote}/{branch}")
        except GitError:
            print(f"[stage0]   ‚ö†Ô∏è  {pkg.name}: –ª–æ–∫–∞–ª—å–Ω–∞—è {branch} —Ä–∞—Å—Ö–æ–¥–∏—Ç—Å—è —Å {remote}/{branch} ‚Äî manual rebase/push")

    else:
        # --- —Å–æ–∑–¥–∞—ë–º dev –∏–∑ base ----------------------------------------
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º ref, –æ—Ç –∫–æ—Ç–æ—Ä–æ–≥–æ –±—É–¥–µ–º —Å–æ–∑–¥–∞–≤–∞—Ç—å –≤–µ—Ç–∫—É.
        if remote_branch_exists(pkg, remote, base):
            start_ref = f"{remote}/{base}"
        elif fallback_head:
            head_proc = _run_git(pkg, ["symbolic-ref", f"refs/remotes/{remote}/HEAD"], capture=True)
            if head_proc.returncode == 0:
                default = head_proc.stdout.strip().split("/")[-1] or base
                print(f"[stage0]   ‚ÑπÔ∏è  {pkg.name}: –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –≤–µ—Ç–∫—É {default} –≤–º–µ—Å—Ç–æ {base}")
                start_ref = f"{remote}/{default}"
            elif fallback_local:
                start_ref = base  # –ª–æ–∫–∞–ª—å–Ω—ã–π base
            else:
                start_ref = base
        else:
            start_ref = base

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω—ã –ª–∏ stash-–æ–ø–µ—Ä–∞—Ü–∏–∏.
        workspace_dirty = bool(_run_git(pkg, ["status", "--porcelain"], capture=True).stdout.strip())
        if workspace_dirty and no_stash:
            print(f"[stage0]   ‚ùå {pkg.name}: –µ—Å—Ç—å –Ω–µ–∑–∞–∫–æ–º–º–∏—á–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è, --no-stash —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω ‚Äî –ø–∞–∫–µ—Ç –ø—Ä–æ–ø—É—â–µ–Ω")
            return False, False, 0, 0

        with temporary_stash(
            pkg,
            enabled=workspace_dirty and not no_stash,
            message=stash_name,
            keep=keep_stash,
        ) as ts:
            checkout_branch(pkg, branch, start_ref)
        stash_kept = ts.kept

    # --- –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ upstream --------------------------------------------
    ensure_tracking(pkg, branch, remote)

    # --- push -----------------------------------------------------------
    push_done = False
    if push and has_commits_to_push(pkg, remote):
        _push_repo(pkg, remote)
        print(f"[stage0]   üöÄ –≤–µ—Ç–∫–∞ {branch} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞")
        push_done = True
    elif push:
        print("[stage0]   üì≠ –∏–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ—Ç ‚Äî push –ø—Ä–æ–ø—É—â–µ–Ω")

    # --- ahead/behind ---------------------------------------------------
    if remote_branch_exists(pkg, remote, branch):
        ahead, behind = calc_ahead_behind(pkg, branch, f"{remote}/{branch}")
    else:
        ahead = behind = 0

    print(f"[stage0]   ‚úÖ {pkg.name}: –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–∞ –≤–µ—Ç–∫–∞ {branch} (–æ—Ç {base})")

    return push_done, stash_kept, ahead, behind


def run(argv: list[str] | None = None) -> None:
    cfg = load_config()
    parser = argparse.ArgumentParser(description="Stage 0: prepare dev branches from base branch")
    parser.add_argument("--branch", default="dev_branch", help="–ò–º—è dev-–≤–µ—Ç–∫–∏")
    parser.add_argument("--base-branch", default="main", help="–ë–∞–∑–æ–≤–∞—è –≤–µ—Ç–∫–∞, –æ—Ç –∫–æ—Ç–æ—Ä–æ–π —Å–æ–∑–¥–∞—ë—Ç—Å—è dev-–≤–µ—Ç–∫–∞")
    parser.add_argument("--push", action="store_true", help="–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–µ—Ç–∫—É –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è")
    parser.add_argument("--dry-run", action="store_true")
    # –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–ª–∞–≥–∏
    parser.add_argument("--no-stash", action="store_true", help="–ù–µ –≤—ã–ø–æ–ª–Ω—è—Ç—å auto-stash, –µ—Å–ª–∏ –µ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è (–∑–∞–≤–µ—Ä—à–∏—Ç—å –æ—à–∏–±–∫–æ–π)")
    parser.add_argument("--stash-name", help="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ stash, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é stage0-auto-<branch>")
    parser.add_argument("--keep-stash", action="store_true", help="–ù–µ —É–¥–∞–ª—è—Ç—å —Å–æ–∑–¥–∞–Ω–Ω—ã–π stash –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ pop –±–µ–∑ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤")
    parser.add_argument("--fallback-head", dest="fallback_head", action=argparse.BooleanOptionalAction, default=True, help="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å origin/HEAD –µ—Å–ª–∏ <base_branch> –Ω–µ –Ω–∞–π–¥–µ–Ω")
    parser.add_argument("--fallback-local", dest="fallback_local", action=argparse.BooleanOptionalAction, default=True, help="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω—É—é –≤–µ—Ç–∫—É <base_branch> –µ—Å–ª–∏ remote –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
    args = parser.parse_args(argv)

    root = pathlib.Path.cwd()
    packages_dir = root / cfg["packages_dir"]
    if not packages_dir.is_dir():
        print(f"[stage0] –∫–∞—Ç–∞–ª–æ–≥ –ø–∞–∫–µ—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω: {packages_dir}", file=sys.stderr)
        sys.exit(1)

    remote_name = cfg.get("git_remote", "origin")

    # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–∞–∫–µ—Ç—ã –ø–æ –Ω–∞–ª–∏—á–∏—é –∫–∞—Ç–∞–ª–æ–≥–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–π (–∫–∞–∫ Stage5/6)
    changes_root = root / cfg.get("changes_output_dir", "release_tool/changes")

    processed = 0
    results: list[PackageResult] = []
    for pkg in sorted(packages_dir.iterdir()):
        if not pkg.is_dir():
            continue
        if not (changes_root / pkg.name).exists():
            # –ø–∞–∫–µ—Ç –Ω–µ —É—á–∞—Å—Ç–≤—É–µ—Ç –≤ —Ç–µ–∫—É—â–µ–º —Ä–µ–ª–∏–∑–µ
            continue
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ remote —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        remote_chk = _run_git(pkg, ["remote", "get-url", remote_name])
        if remote_chk.returncode != 0:
            print(f"[stage0]   ‚ùå {pkg.name}: remote '{remote_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫")
            continue

        print(f"[stage0] –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–∞–∫–µ—Ç: {pkg.name}")
        push_done, stash_kept, ahead, behind = _process_package(
            pkg,
            args.branch,
            args.base_branch,
            remote_name,
            args.push,
            dry_run=args.dry_run or cfg.get("dry_run", False),
            no_stash=args.no_stash,
            stash_name=args.stash_name or f"stage0-auto-{args.branch}",
            keep_stash=args.keep_stash,
            fallback_head=args.fallback_head,
            fallback_local=args.fallback_local,
        )
        # gather summary
        uncommitted_proc = _run_git(pkg, ["status", "--porcelain"])
        uncommitted_flag = bool(uncommitted_proc.stdout.strip())

        results.append(
            PackageResult(
                name=pkg.name,
                push_done=push_done,
                stash_kept=stash_kept,
                ahead=ahead,
                behind=behind,
                uncommitted=uncommitted_flag,
            )
        )
        processed += 1

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∫—Ä–∞—Å–∏–≤—ã–π –æ—Ç—á—ë—Ç
    lines: list[str] = []
    for r in results:
        parts: list[str] = []
        if r.ahead:
            parts.append(f"ahead:{r.ahead}")
        if r.behind:
            parts.append(f"behind:{r.behind}")
        if r.stash_kept:
            parts.append("stash")
        if r.uncommitted:
            parts.append("uncommitted")
        status = ", ".join(parts) if parts else "ok"
        push_status = "–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞" if r.push_done else "–ª–æ–∫–∞–ª—å–Ω–æ"
        lines.append(f"  ‚Ä¢ {r.name:<15} ‚Äî {push_status}; {status}")

    print(f"[stage0] ‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ. –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –ø–∞–∫–µ—Ç–æ–≤: {processed}\n[stage0] –ò—Ç–æ–≥:\n" + "\n".join(lines))


if __name__ == "__main__":
    run() 